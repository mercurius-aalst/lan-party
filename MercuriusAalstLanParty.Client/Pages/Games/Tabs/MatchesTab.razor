@using MercuriusAalstLanParty.Client.Models

<div>
    <h2>Bracket</h2>
    @if(Matches == null || !Matches.Any())
    {
        <p>Geen matches gevonden.</p>
    }
    else
    {
        var rounds = Matches.GroupBy(m => m.RoundNumber).OrderBy(g => g.Key).ToList();
        int lastRound = rounds.Max(r => r.Key);
        int semiFinalRound = lastRound - 1;

        <div style="max-width: 100vw; box-sizing: border-box; overflow-x: auto; padding-bottom: 1rem;">
            <div style="min-width: @(rounds.Count * 220)px;">
                <div class="bracket-titles" style="display: flex; flex-direction: row; align-items: flex-start;">
                    @foreach(var round in rounds)
                    {
                        <div class="bracket-title" style="flex: 1 1 0; text-align: center; min-width: 180px; margin-bottom: 1rem;">
                            <b>
                                @if(round.Key == lastRound)
                                {
                                    @:Final
                                }
                                else if(round.Key == semiFinalRound)
                                {
                                    @:Semi-Final
                                }
                                else
                                {
                                    @($"Ronde {round.Key}")
                                }
                            </b>
                        </div>
                    }
                </div>
                <div class="bracket-absolute-container" style="position: relative; width: @(rounds.Count * 220)px; min-height: 500px;">
                    @* Calculate match positions and render matches absolutely *@
                    @{
                        // Layout constants
                        int matchHeight = 60;
                        int matchWidth = 180;
                        int verticalGap = 40;
                        int roundGap = 40;
                        // Build a dictionary: round -> matches (ordered)
                        var roundMatches = rounds.ToDictionary(r => r.Key, r => r.OrderBy(m => m.MatchNumber).ToList());
                        // Store match positions: matchIndex (int) -> (x, y)
                        var matchPositions = new Dictionary<(int round, int match), (int x, int y)>();
                        int firstRound = rounds.Min(r => r.Key);
                        var firstRoundMatches = roundMatches[firstRound];
                        for(int i = 0; i < firstRoundMatches.Count; i++)
                        {
                            int x = 0;
                            int y = i * (matchHeight + verticalGap);
                            matchPositions[(firstRound, i)] = (x, y);
                        }
                        for(int r = firstRound + 1; r <= lastRound; r++)
                        {
                            var matches = roundMatches[r];
                            for(int i = 0; i < matches.Count; i++)
                            {
                                // For single-elim, match i in round r is fed by matches 2i and 2i+1 in round r-1
                                int srcIdx1 = i * 2;
                                int srcIdx2 = i * 2 + 1;
                                int y1 = matchPositions[(r - 1, srcIdx1)].y + matchHeight / 2;
                                int y2 = matchPositions[(r - 1, srcIdx2)].y + matchHeight / 2;
                                int y = (y1 + y2) / 2;
                                int x = (r - firstRound) * (matchWidth + roundGap);
                                matchPositions[(r, i)] = (x, y);
                            }
                        }
                        int svgWidth = rounds.Count * (matchWidth + roundGap);
                        int svgHeight = matchPositions.Values.Max(pos => pos.y) + matchHeight;
                    }
                    <svg class="bracket-svg" width="@svgWidth" height="@svgHeight" style="position:absolute; left:0; top:0; z-index:0; pointer-events:none;">
                        @for(int r = firstRound + 1; r <= lastRound; r++)
                        {
                            var matches = roundMatches[r];
                            for(int i = 0; i < matches.Count; i++)
                            {
                                int x1 = matchPositions[(r, i)].x;
                                int y1 = matchPositions[(r, i)].y + matchHeight / 2;
                                int srcIdx1 = i * 2;
                                int srcIdx2 = i * 2 + 1;
                                int x0 = matchPositions[(r - 1, srcIdx1)].x + matchWidth;
                                int y0a = matchPositions[(r - 1, srcIdx1)].y + matchHeight / 2;
                                int y0b = matchPositions[(r - 1, srcIdx2)].y + matchHeight / 2;
                                int x1_left = matchPositions[(r, i)].x;
                                int y1_center = matchPositions[(r, i)].y + matchHeight / 2;
                                int xMid = (int)(x0 + (x1_left - x0) * 0.6); // move elbow closer to target
                                                                             // Draw from prev match 1
                                                                             <polyline points="@x0,@y0a @xMid,@y0a @xMid,@y1_center @x1_left,@y1_center" fill="none" stroke="#4caf50" stroke-width="3" />
                                                                             // Draw from prev match 2
                                                                             <polyline points="@x0,@y0b @xMid,@y0b @xMid,@y1_center @x1_left,@y1_center" fill="none" stroke="#4caf50" stroke-width="3" />
                            }
                        }
                    </svg>
                    @foreach(var round in rounds)
                    {
                        int r = round.Key;
                        var matches = roundMatches[r];
                        for(int i = 0; i < matches.Count; i++)
                        {
                            var match = matches[i];
                            var pos = matchPositions[(r, i)];
                            <div class="bracket-match" style="position:absolute; width:@(matchWidth)px; height:@(matchHeight)px; left:@(pos.x)px; top:@(pos.y)px; border:1px solid #4caf50; background-color:white; display:flex; align-items:center; justify-content:center; font-weight:bold; color:#333; flex-direction:column;">
                                <div>
                                    @((match.Participant1Id.HasValue ? $"P1: {match.Participant1Id}" : "-") +
                                                            (match.Participant1Score.HasValue ? $" [{match.Participant1Score}]" : ""))
                                                                                                                                  </div>
                                                                                                                                  <div style="font-size:0.9em; color:#888;">vs</div>
                                                                                                                                  <div>
                                    @((match.Participant2Id.HasValue ? $"P2: {match.Participant2Id}" : "-") +
                                                            (match.Participant2Score.HasValue ? $" [{match.Participant2Score}]" : ""))
                    </div>
                </div>
                                }
                    }
                </div>
            </div>
        </div>
    }
</div>
@code {
    [Parameter] public IEnumerable<Match> Matches { get; set; }
}
